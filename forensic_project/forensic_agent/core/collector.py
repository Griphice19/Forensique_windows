#!/usr/bin/env python3
"""
collector.py - Orchestrateur Principal de l'Agent Forensique Windows
Module central qui coordonne tous les collecteurs d'artefacts
"""

import os
import json
import time
import logging
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

# Imports des modules forensiques
try:
    from .eventlogs import EventLogCollector
    from .registry import RegistryCollector  
    from .network import NetworkCollector
    from .browser import BrowserCollector
    from .usb import USBCollector
    # from .processes import ProcessCollector
    # from .filesystem import FilesystemCollector
except ImportError:
    # Pour les tests standalone
    import sys
    sys.path.append(os.path.dirname(__file__))
    try:
        from eventlogs import EventLogCollector
        from registry import RegistryCollector
        from network import NetworkCollector
        from browser import BrowserCollector
        from usb import USBCollector
    except ImportError as e:
        print(f"‚ö†Ô∏è  Modules manquants: {e}")
        print("Certains collecteurs ne seront pas disponibles")

class ForensicCollector:
    """
    Orchestrateur principal pour la collecte d'artefacts forensiques
    Coordonne tous les modules de collecte et g√©n√®re des rapports unifi√©s
    """
    
    def __init__(self, output_dir: str = "forensic_output"):
        """
        Initialise le collecteur principal
        
        Args:
            output_dir: R√©pertoire de sortie pour les artefacts
        """
        self.output_dir = output_dir
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.session_dir = os.path.join(output_dir, f"collection_{self.session_id}")
        
        # Cr√©ation des r√©pertoires
        os.makedirs(self.session_dir, exist_ok=True)
        os.makedirs(os.path.join(self.session_dir, "raw_data"), exist_ok=True)
        os.makedirs(os.path.join(self.session_dir, "reports"), exist_ok=True)
        
        # Configuration du logging
        self.setup_logging()
        
        # Initialisation des collecteurs
        self.collectors = {}
        self.collection_results = {}
        self.collection_errors = {}
        
        # Statistiques de collecte
        self.start_time = None
        self.end_time = None
        self.total_artifacts = 0
        
        self.logger.info(f"üöÄ Forensic Collector initialis√© - Session: {self.session_id}")

    def setup_logging(self):
        """Configure le syst√®me de logging"""
        log_file = os.path.join(self.session_dir, "collection.log")
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger('ForensicCollector')

    def initialize_collectors(self):
        """Initialise tous les collecteurs disponibles"""
        self.logger.info("üîß Initialisation des collecteurs...")
        
        # EventLogs Collector
        try:
            self.collectors['eventlogs'] = EventLogCollector()
            self.logger.info("‚úÖ EventLogCollector initialis√©")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur EventLogCollector: {e}")
            
        # Registry Collector
        try:
            self.collectors['registry'] = RegistryCollector()
            self.logger.info("‚úÖ RegistryCollector initialis√©")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur RegistryCollector: {e}")
            
        # Network Collector
        try:
            self.collectors['network'] = NetworkCollector()
            self.logger.info("‚úÖ NetworkCollector initialis√©")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur NetworkCollector: {e}")
            
        # Browser Collector
        try:
            self.collectors['browser'] = BrowserCollector()
            self.logger.info("‚úÖ BrowserCollector initialis√©")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur BrowserCollector: {e}")
            
        # USB Collector
        try:
            self.collectors['usb'] = USBCollector()
            self.logger.info("‚úÖ USBCollector initialis√©")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur USBCollector: {e}")
            
        # Futurs collecteurs
        # try:
        #     self.collectors['processes'] = ProcessCollector()
        #     self.logger.info("‚úÖ ProcessCollector initialis√©")
        # except Exception as e:
        #     self.logger.error(f"‚ùå Erreur ProcessCollector: {e}")
            
        self.logger.info(f"üìä {len(self.collectors)} collecteurs initialis√©s")

    def collect_single_module(self, name: str, collector) -> Dict[str, Any]:
        """
        Collecte les donn√©es d'un module sp√©cifique
        
        Args:
            name: Nom du collecteur
            collector: Instance du collecteur
            
        Returns:
            Dictionnaire avec les r√©sultats de la collecte
        """
        start_time = time.time()
        self.logger.info(f"üîç D√©but collecte: {name}")
        
        try:
            # Collecte des donn√©es selon le type de collecteur
            if hasattr(collector, 'collect_all'):
                data = collector.collect_all()
            elif hasattr(collector, 'collect'):
                data = collector.collect()
            elif hasattr(collector, 'analyze_all') and name == 'browser':
                # Sp√©cifique pour BrowserCollector
                data = collector.analyze_all()
            elif hasattr(collector, 'collect_usb_artifacts') and name == 'usb':
                # Sp√©cifique pour USBCollector
                data = collector.collect_usb_artifacts()
            else:
                # Tentative avec les m√©thodes standards
                methods = ['collect_all', 'collect', 'analyze', 'get_data']
                data = None
                for method in methods:
                    if hasattr(collector, method):
                        data = getattr(collector, method)()
                        break
                
                if data is None:
                    raise AttributeError(f"Aucune m√©thode de collecte compatible trouv√©e pour {name}")
            
            # Calcul des statistiques
            artifacts_count = self._count_artifacts(data)
            duration = time.time() - start_time
            
            result = {
                'status': 'success',
                'data': data,
                'artifacts_count': artifacts_count,
                'duration': duration,
                'timestamp': datetime.now().isoformat(),
                'collector_type': name
            }
            
            # Sauvegarde des donn√©es brutes
            self._save_raw_data(name, data)
            
            self.logger.info(f"‚úÖ {name}: {artifacts_count} artefacts en {duration:.2f}s")
            return result
            
        except Exception as e:
            duration = time.time() - start_time
            self.logger.error(f"‚ùå Erreur {name}: {e}")
            
            return {
                'status': 'error',
                'error': str(e),
                'duration': duration,
                'timestamp': datetime.now().isoformat(),
                'collector_type': name
            }

    def collect_all(self, parallel: bool = True, timeout: int = 300) -> Dict[str, Any]:
        """
        Lance la collecte compl√®te de tous les artefacts
        
        Args:
            parallel: Ex√©cution en parall√®le des collecteurs
            timeout: Timeout en secondes pour chaque collecteur
            
        Returns:
            R√©sultats complets de la collecte
        """
        self.start_time = time.time()
        self.logger.info("üöÄ D√©but de la collecte forensique compl√®te")
        
        # Initialisation des collecteurs
        self.initialize_collectors()
        
        if not self.collectors:
            self.logger.error("‚ùå Aucun collecteur disponible")
            return {'status': 'error', 'message': 'Aucun collecteur disponible'}
        
        # Collecte des donn√©es
        if parallel:
            self._collect_parallel(timeout)
        else:
            self._collect_sequential()
        
        self.end_time = time.time()
        
        # G√©n√©ration du rapport final
        return self._generate_final_report()

    def _collect_parallel(self, timeout: int):
        """Collecte en parall√®le avec ThreadPoolExecutor"""
        self.logger.info("üîÑ Collecte en parall√®le...")
        
        with ThreadPoolExecutor(max_workers=len(self.collectors)) as executor:
            # Soumission des t√¢ches
            future_to_collector = {
                executor.submit(self.collect_single_module, name, collector): name
                for name, collector in self.collectors.items()
            }
            
            # R√©cup√©ration des r√©sultats
            for future in as_completed(future_to_collector, timeout=timeout):
                collector_name = future_to_collector[future]
                try:
                    result = future.result()
                    self.collection_results[collector_name] = result
                except Exception as e:
                    self.logger.error(f"‚ùå Erreur dans le thread {collector_name}: {e}")
                    self.collection_errors[collector_name] = str(e)

    def _collect_sequential(self):
        """Collecte s√©quentielle"""
        self.logger.info("üîÑ Collecte s√©quentielle...")
        
        for name, collector in self.collectors.items():
            result = self.collect_single_module(name, collector)
            self.collection_results[name] = result

    def _count_artifacts(self, data: Any) -> int:
        """Compte le nombre d'artefacts dans les donn√©es"""
        if isinstance(data, dict):
            count = 0
            for key, value in data.items():
                if isinstance(value, (list, tuple)):
                    count += len(value)
                elif isinstance(value, dict):
                    # Pour les structures complexes comme browser data
                    if key in ['browsers', 'profiles', 'history', 'bookmarks', 'downloads', 'usb_devices']:
                        count += self._count_artifacts(value)
                    else:
                        count += len(value) if value else 0
                else:
                    count += 1 if value is not None else 0
            return count
        elif isinstance(data, (list, tuple)):
            return len(data)
        else:
            return 1 if data is not None else 0

    def _save_raw_data(self, collector_name: str, data: Any):
        """Sauvegarde les donn√©es brutes"""
        filename = os.path.join(self.session_dir, "raw_data", f"{collector_name}.json")
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False, default=str)
        except Exception as e:
            self.logger.error(f"‚ùå Erreur sauvegarde {collector_name}: {e}")

    def _generate_final_report(self) -> Dict[str, Any]:
        """G√©n√®re le rapport final de collecte"""
        total_duration = self.end_time - self.start_time
        
        # Statistiques globales
        successful_collectors = [name for name, result in self.collection_results.items() 
                               if result.get('status') == 'success']
        failed_collectors = [name for name, result in self.collection_results.items() 
                           if result.get('status') == 'error']
        
        self.total_artifacts = sum(
            result.get('artifacts_count', 0) 
            for result in self.collection_results.values()
            if result.get('status') == 'success'
        )
        
        # Rapport final
        final_report = {
            'session_info': {
                'session_id': self.session_id,
                'start_time': datetime.fromtimestamp(self.start_time).isoformat(),
                'end_time': datetime.fromtimestamp(self.end_time).isoformat(),
                'total_duration': total_duration,
                'output_directory': self.session_dir
            },
            'collection_summary': {
                'total_collectors': len(self.collectors),
                'successful_collectors': len(successful_collectors),
                'failed_collectors': len(failed_collectors),
                'total_artifacts': self.total_artifacts,
                'success_rate': len(successful_collectors) / len(self.collectors) * 100 if self.collectors else 0
            },
            'collector_results': self.collection_results,
            'errors': self.collection_errors,
            'recommendations': self._generate_recommendations()
        }
        
        # Sauvegarde du rapport
        report_file = os.path.join(self.session_dir, "reports", "final_report.json")
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(final_report, f, indent=2, ensure_ascii=False, default=str)
        
        # G√©n√©ration du rapport HTML
        self._generate_html_report(final_report)
        
        self.logger.info(f"üéâ Collecte termin√©e: {self.total_artifacts} artefacts en {total_duration:.2f}s")
        return final_report

    def _generate_recommendations(self) -> List[str]:
        """G√©n√®re des recommandations bas√©es sur les r√©sultats"""
        recommendations = []
        
        # Analyse des r√©sultats pour recommandations
        for collector_name, result in self.collection_results.items():
            if result.get('status') == 'error':
                recommendations.append(f"‚ö†Ô∏è  R√©ex√©cuter {collector_name} avec des privil√®ges √©lev√©s")
            elif result.get('artifacts_count', 0) == 0:
                recommendations.append(f"üîç V√©rifier la configuration de {collector_name}")
        
        # Recommandations sp√©cifiques par type de collecteur
        if 'browser' in self.collection_results:
            browser_result = self.collection_results['browser']
            if browser_result.get('status') == 'success':
                browser_data = browser_result.get('data', {})
                if 'browsers' in browser_data and len(browser_data['browsers']) > 3:
                    recommendations.append("üåê Multiples navigateurs d√©tect√©s - analyser les corr√©lations")
                if any('private' in str(data).lower() for data in browser_data.values() if isinstance(data, (list, dict))):
                    recommendations.append("üîí Navigation priv√©e d√©tect√©e - v√©rifier les artefacts temporaires")
        
        if 'usb' in self.collection_results:
            usb_result = self.collection_results['usb']
            if usb_result.get('status') == 'success':
                usb_data = usb_result.get('data', {})
                if usb_data.get('usb_devices') and len(usb_data['usb_devices']) > 5:
                    recommendations.append("üîå Nombreux p√©riph√©riques USB - analyser les acc√®s r√©cents")
        
        if 'network' in self.collection_results:
            network_result = self.collection_results['network']
            if network_result.get('status') == 'success':
                network_data = network_result.get('data', {})
                if network_data.get('suspicious_connections'):
                    recommendations.append("üö® Connexions suspectes d√©tect√©es - enqu√™te approfondie requise")
        
        if 'eventlogs' in self.collection_results:
            eventlogs_result = self.collection_results['eventlogs']
            if eventlogs_result.get('status') == 'success':
                eventlogs_data = eventlogs_result.get('data', {})
                if eventlogs_data.get('security_events') and len(eventlogs_data['security_events']) > 1000:
                    recommendations.append("üìä Volume √©lev√© d'√©v√©nements de s√©curit√© - filtrage recommand√©")
        
        if 'registry' in self.collection_results:
            registry_result = self.collection_results['registry']
            if registry_result.get('status') == 'success':
                registry_data = registry_result.get('data', {})
                if registry_data.get('startup_programs') and len(registry_data['startup_programs']) > 10:
                    recommendations.append("üöÄ Nombreux programmes au d√©marrage - v√©rifier la l√©gitimit√©")
        
        # Recommandations g√©n√©rales
        if self.total_artifacts > 10000:
            recommendations.append("üìä Volume important d'artefacts - consid√©rer une analyse automatis√©e")
        
        if len(self.collection_errors) > 0:
            recommendations.append("üõ†Ô∏è  Certains collecteurs ont √©chou√© - v√©rifier les logs")
            
        if len(self.collection_results) >= 4:
            recommendations.append("üîó Effectuer une analyse crois√©e entre les diff√©rents types d'artefacts")
            
        return recommendations

    def _generate_html_report(self, report_data: Dict[str, Any]):
        """G√©n√®re un rapport HTML lisible"""
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Rapport Forensique - {self.session_id}</title>
            <meta charset="utf-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
                .summary {{ background: #ecf0f1; padding: 15px; margin: 20px 0; border-radius: 5px; }}
                .success {{ color: #27ae60; }}
                .error {{ color: #e74c3c; }}
                .collector {{ margin: 20px 0; padding: 15px; border: 1px solid #bdc3c7; border-radius: 5px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
                th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #34495e; color: white; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>üîç Rapport de Collecte Forensique</h1>
                <p>Session: {report_data['session_info']['session_id']}</p>
                <p>Dur√©e: {report_data['session_info']['total_duration']:.2f} secondes</p>
            </div>
            
            <div class="summary">
                <h2>üìä R√©sum√©</h2>
                <table>
                    <tr><td>Collecteurs lanc√©s</td><td>{report_data['collection_summary']['total_collectors']}</td></tr>
                    <tr><td>Collecteurs r√©ussis</td><td class="success">{report_data['collection_summary']['successful_collectors']}</td></tr>
                    <tr><td>Collecteurs √©chou√©s</td><td class="error">{report_data['collection_summary']['failed_collectors']}</td></tr>
                    <tr><td>Total artefacts</td><td><strong>{report_data['collection_summary']['total_artifacts']}</strong></td></tr>
                    <tr><td>Taux de r√©ussite</td><td>{report_data['collection_summary']['success_rate']:.1f}%</td></tr>
                </table>
            </div>
            
            <h2>üîß D√©tails des Collecteurs</h2>
        """
        
        # Ordre d'affichage des collecteurs pour la lisibilit√©
        collector_order = ['eventlogs', 'registry', 'network', 'browser', 'usb']
        displayed_collectors = []
        
        # Affichage dans l'ordre pr√©f√©r√©
        for collector_name in collector_order:
            if collector_name in report_data['collector_results']:
                result = report_data['collector_results'][collector_name]
                status_class = "success" if result['status'] == 'success' else "error"
                
                # Ic√¥nes sp√©cifiques par collecteur
                icons = {
                    'eventlogs': 'üìã',
                    'registry': 'üóÇÔ∏è',
                    'network': 'üåê',
                    'browser': 'üåç',
                    'usb': 'üîå'
                }
                
                icon = icons.get(collector_name, 'üìÅ')
                
                html_content += f"""
                <div class="collector">
                    <h3 class="{status_class}">{icon} {collector_name.upper()}</h3>
                    <p>Statut: <span class="{status_class}">{result['status']}</span></p>
                    <p>Dur√©e: {result['duration']:.2f}s</p>
                    <p>Artefacts: {result.get('artifacts_count', 0)}</p>
                    <p>Timestamp: {result['timestamp']}</p>
                """
                
                # Informations sp√©cifiques par type de collecteur
                if result['status'] == 'success' and 'data' in result:
                    data = result['data']
                    if collector_name == 'browser':
                        browsers_count = len(data.get('browsers', []))
                        if browsers_count > 0:
                            html_content += f"<p>Navigateurs d√©tect√©s: {browsers_count}</p>"
                    elif collector_name == 'usb':
                        usb_count = len(data.get('usb_devices', []))
                        if usb_count > 0:
                            html_content += f"<p>P√©riph√©riques USB: {usb_count}</p>"
                    elif collector_name == 'network':
                        connections = len(data.get('active_connections', []))
                        if connections > 0:
                            html_content += f"<p>Connexions actives: {connections}</p>"
                
                html_content += "</div>"
                displayed_collectors.append(collector_name)
        
        # Affichage des collecteurs restants
        for collector_name, result in report_data['collector_results'].items():
            if collector_name not in displayed_collectors:
                status_class = "success" if result['status'] == 'success' else "error"
                html_content += f"""
                <div class="collector">
                    <h3 class="{status_class}">üìÅ {collector_name.upper()}</h3>
                    <p>Statut: <span class="{status_class}">{result['status']}</span></p>
                    <p>Dur√©e: {result['duration']:.2f}s</p>
                    <p>Artefacts: {result.get('artifacts_count', 0)}</p>
                </div>
                """
        
        html_content += """
        </body>
        </html>
        """
        
        html_file = os.path.join(self.session_dir, "reports", "report.html")
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

    def get_session_summary(self) -> Dict[str, Any]:
        """Retourne un r√©sum√© de la session courante"""
        return {
            'session_id': self.session_id,
            'output_dir': self.session_dir,
            'collectors_available': list(self.collectors.keys()),
            'total_artifacts': self.total_artifacts,
            'status': 'completed' if self.end_time else 'running'
        }

def main():
    """Test du collecteur principal"""
    print("üöÄ Test du Forensic Collector Complet")
    print("üìã Collecteurs support√©s: EventLogs, Registry, Network, Browser, USB")
    
    # Cr√©ation du collecteur
    collector = ForensicCollector("test_output")
    
    print(f"\nüîß Session cr√©√©e: {collector.session_id}")
    print(f"üìÇ R√©pertoire de sortie: {collector.session_dir}")
    
    # Lancement de la collecte
    print("\nüöÄ Lancement de la collecte forensique...")
    results = collector.collect_all(parallel=True, timeout=120)
    
    # Affichage des r√©sultats d√©taill√©s
    print(f"\nüìä R√©sultats de la collecte:")
    print(f"‚îú‚îÄ‚îÄ Session: {results['session_info']['session_id']}")
    print(f"‚îú‚îÄ‚îÄ Dur√©e totale: {results['session_info']['total_duration']:.2f}s")
    print(f"‚îú‚îÄ‚îÄ Collecteurs lanc√©s: {results['collection_summary']['total_collectors']}")
    print(f"‚îú‚îÄ‚îÄ Collecteurs r√©ussis: {results['collection_summary']['successful_collectors']}")
    print(f"‚îú‚îÄ‚îÄ Collecteurs √©chou√©s: {results['collection_summary']['failed_collectors']}")
    print(f"‚îú‚îÄ‚îÄ Total artefacts: {results['collection_summary']['total_artifacts']}")
    print(f"‚îú‚îÄ‚îÄ Taux de r√©ussite: {results['collection_summary']['success_rate']:.1f}%")
    print(f"‚îî‚îÄ‚îÄ Rapports: {collector.session_dir}")
    
    # D√©tails par collecteur
    print(f"\nüîç D√©tails par collecteur:")
    for collector_name, result in results['collector_results'].items():
        status_icon = "‚úÖ" if result['status'] == 'success' else "‚ùå"
        print(f"{status_icon} {collector_name.upper()}: {result.get('artifacts_count', 0)} artefacts en {result['duration']:.2f}s")
    
    # Recommandations
    if results.get('recommendations'):
        print(f"\nüí° Recommandations:")
        for rec in results['recommendations']:
            print(f"  {rec}")
    
    print(f"\nüìã Fichiers g√©n√©r√©s:")
    print(f"‚îú‚îÄ‚îÄ Logs: {collector.session_dir}/collection.log")
    print(f"‚îú‚îÄ‚îÄ Rapport JSON: {collector.session_dir}/reports/final_report.json")
    print(f"‚îú‚îÄ‚îÄ Rapport HTML: {collector.session_dir}/reports/report.html")
    print(f"‚îî‚îÄ‚îÄ Donn√©es brutes: {collector.session_dir}/raw_data/")

if __name__ == "__main__":
    main()